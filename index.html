<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BEDROCK ADDON PATCHER</title>

<link href="https://fonts.googleapis.com/css2?family=Minecraft&display=swap" rel="stylesheet">
<style>
body {
    font-family: "Minecraft", Arial, sans-serif;
    background-color: #1a1a1a;
    color: white;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
}
.container {
    width: 90%;
    max-width: 900px;
    background: rgba(0,0,0,0.8);
    padding: 25px;
    margin: 40px auto;
    border-radius: 8px;
    box-shadow: 0 0 20px #00aaff;
}
h1 { text-align:center; color: #ffd700; }
.input-section { display:flex; flex-direction:column; gap:20px; margin-bottom:20px; }
.file-input-label {
    display:inline-block; padding:12px 24px; background-color:#5a8b2a; cursor:pointer; border-radius:4px;
}
.generate-btn {
    padding:12px 24px; background-color:#ff4444; border:none; cursor:pointer; color:white; border-radius:4px;
}
.progress-bar { width:100%; height:8px; background:#333; margin-top:10px; overflow:hidden; }
.progress-fill { height:100%; width:0; background:linear-gradient(90deg,#ff4444,#ffd700); transition:width 0.3s; }
#file-name, #output { margin-top:10px; }
.uuid-card { background:rgba(0,0,0,0.7); border:2px solid #00d4f5; padding:10px; margin:5px; display:inline-block; }
.error { color:#ff5555; }
.success { color:#2fd4ff; }
.processing { color:#ffd700; }
.status-icon { margin-right:5px; }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.0/dist/browser-image-compression.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.10.0/dist/ffmpeg.min.js"></script>
</head>

<body>
<div class="container">
    <h1>üß± BEDROCK ADDON PATCHER ‚öíÔ∏è</h1>

    <div class="input-section">
        <label for="addon-file" class="file-input-label">CHOOSE .MCADDON OR .ZIP FILE</label>
        <input type="file" id="addon-file" accept=".mcaddon,.zip" style="display:none;">
        <div id="file-name"></div>
        <button class="generate-btn" id="generate-uuids">GENERATE NEW UUIDS</button>
    </div>

    <div class="progress-bar" id="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>
    <div class="output-section" id="output-section">
        <div id="output"></div>
        <div id="uuid-display"></div>
    </div>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
    const fileInput = document.getElementById("addon-file");
    const fileNameDisplay = document.getElementById("file-name");
    const generateBtn = document.getElementById("generate-uuids");
    const outputSection = document.getElementById("output-section");
    const output = document.getElementById("output");
    const uuidDisplay = document.getElementById("uuid-display");
    const progressBar = document.getElementById("progress-bar");
    const progressFill = document.getElementById("progress-fill");

    const ffmpeg = FFmpeg.createFFmpeg({ log: false });

    const showError = (msg) => {
        outputSection.classList.add("active");
        output.innerHTML = `<div class="error"><span class="status-icon">‚ùå</span>${msg}</div>`;
        progressBar.classList.remove("active");
    };
    const showStatus = (msg) => {
        outputSection.classList.add("active");
        output.innerHTML = `<div class="processing"><span class="status-icon">‚è≥</span>${msg}</div>`;
    };
    const showSuccess = (msg) => {
        outputSection.classList.add("active");
        output.innerHTML = `<div class="success"><span class="status-icon">‚ú®</span>${msg}</div>`;
    };
    const updateProgress = (percent,msg="") => {
        progressFill.style.width = percent + "%";
        if(msg) showStatus(msg);
    };
    const formatBytes = (bytes) => {
        if(bytes===0)return "0 B";
        const k=1024,s=["B","KB","MB","GB"],i=Math.floor(Math.log(bytes)/Math.log(k));
        return parseFloat((bytes/Math.pow(k,i)).toFixed(2))+" "+s[i];
    };
    const makeUuid = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,c=>{
        const r = (Math.random()*16)|0; return (c==='x'?r:(r&0x3)|0x8).toString(16);
    });
    const download = (blob, filename) => {
        const a=document.createElement("a");
        a.href=URL.createObjectURL(blob);
        a.download=filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    };

    const findPackManifests = async (zip) => {
        let resManifest=null, behManifest=null;
        for(const path in zip.files){
            if(path.toLowerCase().endsWith("manifest.json")){
                const content = await zip.file(path).async("string");
                if(path.startsWith("data/") && !behManifest) behManifest={path,json:JSON.parse(content)};
                else if(path.startsWith("resources/") && !resManifest) resManifest={path,json:JSON.parse(content)};
            }
        }
        return {resManifest,behManifest};
    };

    const updateManifest = (json,uuidMap)=>{
        if(json.header && typeof json.header.name==="string" && !json.header.name.endsWith(" - Patch"))
            json.header.name+=" - Patch";
        const uuidRegex=/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        const deepReplace=(obj)=>{
            for(const key in obj){
                if(!obj.hasOwnProperty(key)) continue;
                const val=obj[key];
                if(typeof val==="string" && uuidRegex.test(val) && uuidMap[val]) obj[key]=uuidMap[val];
                else if(val && typeof val==="object") deepReplace(val);
            }
        };
        deepReplace(json);
    };

    const ensureDependencies=(behJson,resJson,newRes,newBeh)=>{
        if(!behJson.dependencies) behJson.dependencies=[];
        if(!behJson.dependencies.some(d=>d.uuid===newRes)) behJson.dependencies.push({uuid:newRes,version:resJson.header.version||[1,0,0]});
        if(!resJson.dependencies) resJson.dependencies=[];
        if(!resJson.dependencies.some(d=>d.uuid===newBeh)) resJson.dependencies.push({uuid:newBeh,version:behJson.header.version||[1,0,0]});
    };

    const compressFiles = async (zip)=>{
        const paths=Object.keys(zip.files);
        for(let i=0;i<paths.length;i++){
            const path = paths[i];
            const file = zip.file(path);
            if(!file) continue;
            const blob = await file.async("blob");

            // Image compression
            if(blob.type.startsWith("image/")){
                try{
                    const compressed = await imageCompression(blob,{
                        maxSizeMB:1,maxWidthOrHeight:null,useWebWorker:true,fileType:blob.type,initialQuality:1
                    });
                    zip.file(path,compressed,{compression:"DEFLATE",compressionOptions:{level:9}});
                }catch(err){
                    console.warn(`Skipping invalid image: ${path}`,err);
                }
            } 
            // Audio compression
            else if(blob.type.startsWith("audio/") || /\.(mp3|wav|ogg|flac)$/i.test(path)){
                try{
                    if(!ffmpeg.isLoaded()) await ffmpeg.load();
                    ffmpeg.FS("writeFile","input_audio"+i,await FFmpeg.fetchFile(blob));
                    await ffmpeg.run("-i","input_audio"+i,"-c:a","copy","output_audio"+i);
                    const data = ffmpeg.FS("readFile","output_audio"+i);
                    zip.file(path,new Blob([data.buffer],{type:blob.type}),{compression:"DEFLATE",compressionOptions:{level:9}});
                    ffmpeg.FS("unlink","input_audio"+i); ffmpeg.FS("unlink","output_audio"+i);
                }catch(err){
                    console.warn(`Skipping invalid audio: ${path}`,err);
                }
            }

            updateProgress(70 + Math.floor(20*(i/paths.length)),`Compressing files: ${i+1}/${paths.length}`);
        }
    };

    fileInput.addEventListener("change",()=>{
        const file=fileInput.files[0];
        if(!file){fileNameDisplay.textContent=""; return;}
        fileNameDisplay.innerHTML = `<strong>File Loaded:</strong> ${file.name}<br/><strong>Original Size:</strong> ${formatBytes(file.size)}`;
        showStatus("File loaded. Ready to generate UUIDs and optimize.");
    });

    generateBtn.addEventListener("click",async ()=>{
        const file = fileInput.files[0];
        outputSection.classList.remove("active"); uuidDisplay.innerHTML=""; output.innerHTML="";
        progressBar.classList.add("active"); updateProgress(0,"Starting process...");

        if(!file) return showError("Please select a .mcaddon or .zip file first!");

        try{
            updateProgress(10,"Loading file into ZIP...");
            const zip = await JSZip.loadAsync(file);

            updateProgress(30,"Finding manifests...");
            const {resManifest,behManifest}=await findPackManifests(zip);
            if(!resManifest || !behManifest) return showError("Could not locate both 'resources' and 'data' manifests.");

            updateProgress(50,"Generating new UUIDs...");
            const oldRes=resManifest.json.header.uuid;
            const oldBeh=behManifest.json.header.uuid;
            const newRes=makeUuid();
            const newBeh=makeUuid();
            const uuidMap={[oldRes]:newRes,[oldBeh]:newBeh};

            updateManifest(resManifest.json,uuidMap);
            updateManifest(behManifest.json,uuidMap);
            ensureDependencies(behManifest.json,resManifest.json,newRes,newBeh);

            zip.file(resManifest.path,JSON.stringify(resManifest.json,null,2));
            zip.file(behManifest.path,JSON.stringify(behManifest.json,null,2));

            updateProgress(60,"Compressing images and audio...");
            await compressFiles(zip);

            updateProgress(90,"Generating updated ZIP...");
            const blob = await zip.generateAsync({type:"blob",compression:"DEFLATE",compressionOptions:{level:9}});

            const originalSize=file.size, finalSize=blob.size;
            const compressionRatio=((1-finalSize/originalSize)*100).toFixed(2);

            download(blob,file.name.replace(/\.(mcaddon|zip)$/i,"_updated.$1"));
            updateProgress(100,"Addon ready! Download starting...");

            showSuccess("Success! Your updated addon is downloading...");
            uuidDisplay.innerHTML = `<div class="uuid-card"><h3>RESOURCE UUID</h3><p>${newRes}</p></div>
                                     <div class="uuid-card"><h3>BEHAVIOR UUID</h3><p>${newBeh}</p></div>`;
            outputSection.innerHTML += `<div class="success">
                <strong>Original Size:</strong> ${formatBytes(originalSize)}<br/>
                <strong>Final Size:</strong> ${formatBytes(finalSize)}<br/>
                <strong>Compression Ratio:</strong> ${compressionRatio}% saved
            </div>`;

            setTimeout(()=>progressBar.classList.remove("active"),2000);
        }catch(e){
            console.error(e);
            showError("Error: "+e.message);
        }
    });

});
</script>
</body>
</html>
